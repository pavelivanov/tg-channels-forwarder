# Implementation Plan: Telegram Mini App (Frontend)

**Branch**: `013-telegram-mini-app` | **Date**: 2026-02-18 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/013-telegram-mini-app/spec.md`

## Summary

Build a React SPA served at `/app` via the existing NestJS API that lets users manage their subscription lists through Telegram's Mini App platform. The app uses `@twa-dev/sdk` for Telegram WebApp integration, authenticates via `POST /auth/validate` with initData, stores the JWT in memory, and consumes existing CRUD endpoints for channels and subscription lists. Styled entirely with Telegram CSS theme variables for native appearance.

## Technical Context

**Language/Version**: TypeScript 5.x with `strict: true`, React 19, Node.js 20 LTS
**Primary Dependencies**: React 19, React Router 7, Vite 6, `@twa-dev/sdk`, `@nestjs/serve-static` (API-side)
**Storage**: N/A (frontend-only; backend handles all persistence)
**Testing**: Vitest + jsdom + @testing-library/react
**Target Platform**: Telegram WebApp iframe (mobile + desktop Telegram clients)
**Project Type**: Frontend SPA within existing monorepo (`apps/mini-app`)
**Performance Goals**: Initial load < 3 seconds, form interactions < 100ms perceived latency
**Constraints**: JWT in memory only (no localStorage), max 30 source channels per list, no external CSS framework
**Scale/Scope**: 3 screens (Home, Create List, Edit List), ~7 components, ~4 hooks, ~2 pages, ~2 lib modules

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. TypeScript Strict Mode & Code Quality | PASS | `strict: true` inherited from shared tsconfig. ESLint + Prettier configured. Clean public API via index.ts exports. |
| II. Vitest Testing Standards | PASS | Vitest + jsdom + @testing-library/react. Tests cover auth flow, form validation, CRUD operations, error states. |
| III. Observability & Logging | EXEMPT | Principle III mandates pino for "every service and app." Pino is a Node.js server-side library that cannot run in browser environments. This frontend SPA is exempt from pino usage. No `console.log` in production code — enforced via ESLint rule `no-console` with `warn`/`error` allowed in dev only. Constitution amendment recommended to clarify Principle III applies to server-side apps. |
| IV. Performance Requirements | PASS | < 3s load target. Vite tree-shaking + code splitting keeps bundle small. No unbounded caches. |
| V. Technology Stack & Monorepo | PASS | App lives in `apps/mini-app` within existing Turborepo. `build`, `test`, `lint` scripts defined. |
| VI. Docker-First Deployment | PASS | Existing Dockerfile updated for multi-stage build (Vite build → nginx or API static serving). Health check via API. |
| VII. Data Architecture | N/A | Frontend-only, no direct database or Redis access. |

**Quality Gates**:
- ESLint + Prettier pass via `turbo run lint`
- `turbo run test` passes with zero failures
- `turbo run build` succeeds
- Constitution principles verified

## Project Structure

### Documentation (this feature)

```text
specs/013-telegram-mini-app/
├── plan.md              # This file
├── research.md          # Technology decisions
├── data-model.md        # Frontend state model
├── quickstart.md        # Integration scenarios
├── contracts/
│   └── api-contract.md  # Backend API endpoints consumed
└── tasks.md             # Task breakdown (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
apps/mini-app/
├── index.html                # Vite entry point
├── package.json              # React + Vite deps
├── tsconfig.json             # Extends shared tsconfig
├── vite.config.ts            # Vite config with proxy + base path
├── src/
│   ├── main.tsx              # React root + router setup
│   ├── App.tsx               # Root component with AuthProvider
│   ├── router.tsx            # React Router config (basename: '/app')
│   ├── components/
│   │   ├── ChannelSelector.tsx       # Multi-select for source channels
│   │   ├── AddChannelForm.tsx        # Inline @username registration
│   │   ├── SubscriptionListCard.tsx  # Home screen list item
│   │   ├── EmptyState.tsx            # No-lists prompt
│   │   ├── ErrorMessage.tsx          # Inline error display
│   │   ├── LoadingSpinner.tsx        # Loading indicator
│   │   └── TelegramGuard.tsx         # Outside-Telegram detection
│   ├── pages/
│   │   ├── HomePage.tsx              # List of subscription lists
│   │   └── ListFormPage.tsx          # Create + Edit form (shared)
│   ├── hooks/
│   │   ├── useAuth.ts               # Auth context consumer hook
│   │   ├── useApi.ts                 # Authenticated fetch wrapper
│   │   ├── useSubscriptionLists.ts   # List CRUD operations
│   │   └── useChannels.ts           # Channel fetch + add operations
│   ├── context/
│   │   └── AuthContext.tsx           # Auth state provider
│   ├── lib/
│   │   ├── api-client.ts            # Base fetch with auth + 401 retry
│   │   └── telegram.ts              # WebApp SDK helpers
│   ├── types/
│   │   └── index.ts                 # Shared TypeScript interfaces
│   └── styles/
│       └── global.css               # Telegram theme variable mappings
├── test/
│   ├── setup.ts                     # Vitest setup (jsdom, mocks)
│   ├── auth.spec.ts                 # Auth flow tests
│   ├── home.spec.ts                 # Home screen tests
│   ├── list-form.spec.ts            # Create/Edit form tests
│   └── add-channel.spec.ts          # Add channel flow tests
└── Dockerfile                       # Multi-stage build

apps/api/
├── src/
│   └── app.module.ts                # Add ServeStaticModule import
└── package.json                     # Add @nestjs/serve-static dep
```

**Structure Decision**: The mini-app is a standalone SPA in `apps/mini-app` within the existing Turborepo monorepo. It follows the standard Vite + React project layout. The API serves the built static files via `@nestjs/serve-static`. No shared packages are created — the mini-app communicates with the API purely via HTTP.

## Complexity Tracking

No constitution violations. The plan stays within the existing monorepo structure and uses established patterns.
