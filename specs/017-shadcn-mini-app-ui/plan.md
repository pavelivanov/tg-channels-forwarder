# Implementation Plan: Shadcn Mini App UI

**Branch**: `017-shadcn-mini-app-ui` | **Date**: 2026-02-19 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/017-shadcn-mini-app-ui/spec.md`

## Summary

Migrate the Telegram Mini App (`apps/mini-app`) from ad-hoc inline `React.CSSProperties` objects to shadcn/ui components with Tailwind CSS v4. All shadcn color tokens are mapped to Telegram's `--tg-theme-*` CSS variables so the app inherits the user's theme automatically. The migration replaces all inline styles with utility classes and reusable components (Button, Card, Input, Label, Checkbox, Badge, Separator, Skeleton) while preserving all existing functionality, routing, and API interactions.

## Technical Context

**Language/Version**: TypeScript 5.8.3, React 19.1.0
**Primary Dependencies**: shadcn/ui (component source, copy-paste), Tailwind CSS v4 (`@tailwindcss/vite`), class-variance-authority, clsx, tailwind-merge, lucide-react, tw-animate-css
**Storage**: N/A (frontend-only, no data changes)
**Testing**: Vitest 3.1.4 + @testing-library/react 16.3.0
**Target Platform**: Telegram Mini App (mobile WebView, iOS/Android)
**Project Type**: Frontend SPA within existing Turborepo monorepo
**Performance Goals**: Production bundle increase < 50 kB gzipped (NFR-001)
**Constraints**: Must map to Telegram `--tg-theme-*` runtime CSS variables; no `.dark` class toggle; must work at `/app` base path
**Scale/Scope**: 2 pages, 6 components, 1 global stylesheet, ~15 files to modify

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|---|---|---|
| I. TypeScript Strict Mode & Code Quality | PASS | `strict: true` already enabled. shadcn components are TypeScript. No `any` types. New dependencies are well-established libraries. |
| II. Vitest Testing Standards | PASS | Existing tests must continue passing (NFR-003). New shadcn components are copy-pasted source — tests can import and render them directly. |
| III. Observability & Logging | JUSTIFIED | Frontend SPA — no pino, no structured logging. Browser console is the only logging target. This is consistent with the existing mini-app approach. |
| IV. Performance Requirements | PASS | Bundle size constraint (< 50 kB gzipped increase) is explicit in NFR-001. Tailwind tree-shakes aggressively. Estimated ~10–15 kB total increase. |
| V. Technology Stack & Monorepo | PASS | Stays within Turborepo structure. `apps/mini-app` already has `build`, `test`, and `lint` scripts. shadcn/ui is well-established (constitution: "well-established libraries MUST be preferred"). |
| VI. Docker-First Deployment | PASS | No Docker changes needed. `apps/mini-app/Dockerfile` builds with `vite build` — Tailwind runs at build time. |
| VII. Data Architecture | N/A | No data changes. |

## Project Structure

### Documentation (this feature)

```text
specs/017-shadcn-mini-app-ui/
├── plan.md              # This file
├── spec.md              # Feature specification
├── research.md          # Technology decisions (R1–R8)
├── quickstart.md        # Manual test scenarios (TS1–TS10)
├── checklists/
│   └── requirements.md  # Specification quality checklist
└── tasks.md             # Task breakdown (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
apps/mini-app/
├── components.json                  # NEW — shadcn configuration
├── tsconfig.json                    # MODIFIED — add @/* path alias
├── vite.config.ts                   # MODIFIED — add Tailwind plugin + @ alias
├── src/
│   ├── main.tsx                     # MODIFIED — import path for globals.css
│   ├── styles/
│   │   └── global.css               # REPLACED — Tailwind v4 + Telegram theme mapping
│   ├── lib/
│   │   └── utils.ts                 # NEW — cn() utility (clsx + tailwind-merge)
│   ├── components/
│   │   ├── ui/                      # NEW — shadcn component source files
│   │   │   ├── button.tsx
│   │   │   ├── card.tsx
│   │   │   ├── input.tsx
│   │   │   ├── label.tsx
│   │   │   ├── checkbox.tsx
│   │   │   ├── badge.tsx
│   │   │   ├── separator.tsx
│   │   │   └── skeleton.tsx
│   │   ├── AddChannelForm.tsx       # MODIFIED — use shadcn Input, Button, Label
│   │   ├── ChannelSelector.tsx      # MODIFIED — use shadcn Checkbox, Label
│   │   ├── EmptyState.tsx           # MODIFIED — use shadcn Button, add icon
│   │   ├── ErrorMessage.tsx         # MODIFIED — use Tailwind classes
│   │   ├── LoadingSpinner.tsx       # MODIFIED — use shadcn Skeleton or Tailwind animation
│   │   ├── SubscriptionListCard.tsx # MODIFIED — use shadcn Card, Badge
│   │   └── TelegramGuard.tsx        # MODIFIED — use Tailwind classes
│   ├── pages/
│   │   ├── HomePage.tsx             # MODIFIED — use shadcn Card, Button, Badge, Skeleton
│   │   └── ListFormPage.tsx         # MODIFIED — use shadcn Input, Label, Button, Card
│   ├── context/
│   │   └── AuthContext.tsx           # MINIMAL — remove any inline styles if present
│   ├── hooks/                       # UNCHANGED
│   ├── lib/
│   │   ├── api-client.ts            # UNCHANGED
│   │   └── telegram.ts              # UNCHANGED
│   ├── router.tsx                   # UNCHANGED
│   └── types/
│       └── index.ts                 # UNCHANGED
└── test/                            # MODIFIED — update selectors if needed
```

**Structure Decision**: No new directories beyond `src/components/ui/` (shadcn convention) and `src/lib/utils.ts`. The existing component/page/hook structure is preserved. All changes happen within `apps/mini-app/` — no other packages are affected.

## Key Design Decisions

### 1. Telegram Theme → shadcn Token Mapping

The core integration: override shadcn's `:root` CSS variables to reference Telegram's runtime-injected `--tg-theme-*` variables. No `.dark` class needed — Telegram handles theme switching by updating its own CSS variables.

```css
:root {
  --background: var(--tg-theme-bg-color, #ffffff);
  --foreground: var(--tg-theme-text-color, #000000);
  --card: var(--tg-theme-section-bg-color, #ffffff);
  --card-foreground: var(--tg-theme-text-color, #000000);
  --primary: var(--tg-theme-button-color, #2678b6);
  --primary-foreground: var(--tg-theme-button-text-color, #ffffff);
  --secondary: var(--tg-theme-secondary-bg-color, #f0f0f0);
  --secondary-foreground: var(--tg-theme-text-color, #000000);
  --muted: var(--tg-theme-secondary-bg-color, #f0f0f0);
  --muted-foreground: var(--tg-theme-hint-color, #999999);
  --accent: var(--tg-theme-button-color, #2678b6);
  --accent-foreground: var(--tg-theme-button-text-color, #ffffff);
  --destructive: var(--tg-theme-destructive_text_color, #ff3b30);
  --border: var(--tg-theme-hint-color, #c8c8c8);
  --input: var(--tg-theme-hint-color, #c8c8c8);
  --ring: var(--tg-theme-button-color, #2678b6);
  --radius: 0.625rem;
}
```

Then `@theme inline {}` maps these to Tailwind utility classes — `bg-primary`, `text-muted-foreground`, etc. All unchanged from shadcn's default.

### 2. No Dark Mode Toggle

Telegram's WebApp SDK injects and updates `--tg-theme-*` variables at runtime based on the user's chosen theme. We do NOT need a `.dark` class, a `useTheme()` hook, or any dark mode detection. The CSS variable chain handles it:

```
Telegram runtime → --tg-theme-* → :root shadcn tokens → @theme inline → Tailwind classes
```

### 3. Tailwind v4 Vite Plugin (No PostCSS)

Using `@tailwindcss/vite` instead of PostCSS. This means:
- No `postcss.config.js` file needed
- No `autoprefixer` needed (built into Lightning CSS)
- Configuration lives in CSS via `@theme {}` blocks, not `tailwind.config.js`

### 4. Component Migration Strategy

Each existing component maps to shadcn primitives:

| Current component | Migration approach |
|---|---|
| `<button style={...}>` | → `<Button variant="default\|outline\|destructive\|ghost">` |
| `<div style={cardStyle}>` | → `<Card>` / `<CardContent>` |
| `<input style={...}>` | → `<Input>` with `<Label>` |
| `<input type="checkbox">` | → `<Checkbox>` (Radix-based, styled) |
| `<div style={badgeStyle}>` | → `<Badge variant="default\|secondary\|outline">` |
| `LoadingSpinner` (injected `<style>`) | → `<Skeleton>` or Tailwind `animate-pulse` class |
| `ErrorMessage` (className="error") | → `<p className="text-sm text-destructive">` |
| `EmptyState` (text only) | → Add `lucide-react` icon + shadcn `Button` |

### 5. Form Field-Level Validation

Wrap form fields in a pattern:
```tsx
<div className="space-y-2">
  <Label htmlFor="name">List Name</Label>
  <Input id="name" className={error ? "border-destructive" : ""} />
  {error && <p className="text-sm text-destructive">{error}</p>}
</div>
```

This replaces the current single `<ErrorMessage>` at page bottom with per-field inline errors.

## Complexity Tracking

| Violation | Why Needed | Simpler Alternative Rejected Because |
|---|---|---|
| III. Observability (no pino) | Frontend SPA has no server runtime; browser console is the logging target | Adding pino to a client-side React app adds complexity for no user benefit; existing mini-app uses no structured logging |
| II. Testing (shadcn UI components) | 8 files in `src/components/ui/` are generated by `npx shadcn@latest add` — vendored third-party code, not team-authored | Writing tests for generated code that contains no custom logic provides no value; the upstream shadcn/ui project maintains its own test suite. `src/lib/utils.ts` IS tested (T010) since it's project code. |
